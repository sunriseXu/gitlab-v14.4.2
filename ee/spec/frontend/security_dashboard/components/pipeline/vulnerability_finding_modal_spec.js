import { GlModal } from '@gitlab/ui';
import { shallowMount } from '@vue/test-utils';
import VulnerabilityFindingModal from 'ee/security_dashboard/components/pipeline/vulnerability_finding_modal.vue';
import SolutionCard from 'ee/vue_shared/security_reports/components/solution_card_vuex.vue';
import VulnerabilityDetailsGraphql from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';

const TEST_VULNERABILITY = {
  name: 'foo',
  description: `Bracket object notation with user input is present, this might allow an attacker to access all properties of the object and even it's prototype, leading to possible code execution.`,
  severity: 'CRITICAL',
  project: {
    name: 'gitlab.com',
    webUrl: 'http://gitlab.com',
  },
  solution: 'foo',
  hasMergeRequest: false,
  remediations: [{}],
};

describe('Vulnerability finding modal', () => {
  let wrapper;

  const createWrapper = (options = {}) =>
    shallowMount(VulnerabilityFindingModal, {
      propsData: {
        finding: TEST_VULNERABILITY,
      },
      ...options,
    });

  const findModal = () => wrapper.findComponent(GlModal);
  const findVulnerabilityDetails = () => wrapper.findComponent(VulnerabilityDetailsGraphql);
  const findSolutionCard = () => wrapper.findComponent(SolutionCard);

  beforeEach(() => {
    wrapper = createWrapper();
  });

  afterEach(() => {
    wrapper.destroy();
  });

  describe('modal instance', () => {
    it('gets passed the correct props', () => {
      expect(findModal().props()).toMatchObject({
        title: TEST_VULNERABILITY.name,
        modalId: expect.any(String),
      });
    });

    it('makes the component emit "hide" when the modal gets closed', () => {
      expect(wrapper.emitted('hide')).toBeUndefined();

      findModal().vm.$emit('hide');

      expect(wrapper.emitted('hide')).toHaveLength(1);
    });
  });

  describe('finding details', () => {
    it('displays details about the given vulnerability finding', () => {
      const { description, severity } = TEST_VULNERABILITY;

      expect(findVulnerabilityDetails().props()).toMatchObject({
        description,
        severity,
      });
    });
  });

  describe('solution card', () => {
    it('gets passed the correct props', () => {
      expect(findSolutionCard().props()).toMatchObject({
        solution: TEST_VULNERABILITY.solution,
        hasMr: TEST_VULNERABILITY.hasMergeRequest,
        remediation: TEST_VULNERABILITY.remediations[0],
      });
    });

    it.each`
      condition                                | expectedHasDownloadValue | vulnerabilityData
      ${'merge request and remediations diff'} | ${true}                  | ${{ hasMergeRequest: false, remediations: [{ diff: ['foo'] }] }}
      ${'merge request'}                       | ${false}                 | ${{ hasMergeRequest: true }}
      ${'no remediation'}                      | ${false}                 | ${{ remediations: [] }}
      ${'no remediation diff'}                 | ${false}                 | ${{ remediations: [{ diff: [] }] }}
    `(
      'gets passed the "hasDownload" prop as "$expectedHasDownloadValue" when the vulnerability has $condition',
      ({ vulnerabilityData, expectedHasDownloadValue }) => {
        wrapper = createWrapper({
          propsData: {
            finding: { ...TEST_VULNERABILITY, ...vulnerabilityData },
          },
        });

        expect(findSolutionCard().props('hasDownload')).toBe(expectedHasDownloadValue);
      },
    );
  });
});
