import { nextTick } from 'vue';
import { shallowMount } from '@vue/test-utils';
import { GlAlert, GlModal } from '@gitlab/ui';
import { getCookie, setCookie } from '~/lib/utils/common_utils';
import { stubComponent } from 'helpers/stub_component';
import AgentVulnerabilityReport from 'ee/security_dashboard/components/agent/agent_vulnerability_report.vue';
import VulnerabilityReport from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_report.vue';
import { mockTracking, unmockTracking } from 'helpers/tracking_helper';
import { trackAgentSecurityTabAlert } from 'ee/security_dashboard/components/agent/constants';
import {
  FIELD_PRESETS,
  FILTER_PRESETS,
} from 'ee/security_dashboard/components/shared/vulnerability_report/constants';

jest.mock('~/lib/utils/common_utils', () => ({
  parseBoolean: jest.requireActual('~/lib/utils/common_utils').parseBoolean,
  getCookie: jest.fn().mockReturnValue(false),
  setCookie: jest.fn(),
}));

describe('Agent vulnerability report component', () => {
  let wrapper;

  const propsData = { clusterAgentId: 'gid://gitlab/Clusters::Agent/1' };
  const provide = { agentName: 'primary-agent', projectPath: '/path/to/project/' };

  const findAlert = () => wrapper.findComponent(GlAlert);
  const findReport = () => wrapper.findComponent(VulnerabilityReport);
  const findModal = () => wrapper.findComponent(GlModal);

  const createWrapper = () => {
    wrapper = shallowMount(AgentVulnerabilityReport, {
      propsData,
      provide,
      stubs: { GlModal: stubComponent(GlModal) },
    });
  };

  afterEach(() => {
    wrapper.destroy();
  });

  describe('default', () => {
    beforeEach(() => {
      createWrapper();
    });

    it('passes the expected props to the vulnerability report component', () => {
      expect(findReport().props()).toMatchObject({
        fields: FIELD_PRESETS.AGENT,
        filterDropdowns: FILTER_PRESETS.AGENT,
        filterFn: wrapper.vm.transformFilters,
      });
    });

    it('shows the vulnerability alert if there is no cookie', () => {
      expect(findAlert().exists()).toBe(true);
    });

    it('opens the modal when a user dismisses the alert', async () => {
      const spy = jest.spyOn(findModal().vm, 'show');

      expect(spy).not.toHaveBeenCalled();

      findAlert().vm.$emit('dismiss');
      await nextTick();

      expect(spy).toHaveBeenCalled();
    });

    it('sets the cookie when a user verifies they do not want to view the alert', async () => {
      expect(setCookie).not.toHaveBeenCalled();
      const modal = findModal();
      findAlert().vm.$emit('dismiss');
      await nextTick();
      modal.vm.$emit('primary');
      await nextTick();
      expect(setCookie).toHaveBeenCalled();
    });

    describe('snowplow tracking', () => {
      afterEach(() => {
        unmockTracking();
      });

      it('tracks the Snowplow event when a user verifies they do not want to view the alert', async () => {
        const { category, action } = trackAgentSecurityTabAlert;
        const trackingSpy = mockTracking(category, wrapper.vm.$el, jest.spyOn);
        expect(trackingSpy).not.toHaveBeenCalled();
        findAlert().vm.$emit('dismiss');
        await nextTick();
        findModal().vm.$emit('primary');
        await nextTick();
        expect(trackingSpy).toHaveBeenCalledWith(category, action);
      });
    });
  });

  it('hides the vulnerability alert if there is a cookie', async () => {
    getCookie.mockImplementationOnce(() => true);
    createWrapper();
    await nextTick();
    expect(findAlert().exists()).toBe(false);
  });
});
